import OpenAI from 'openai';
import { BaseAIService } from '../AIServiceInterface';
import type {
  AIProvider,
  AIServiceConfig,
  MealPlanRequest,
  MealPlanResponse,
  TrainingPlanRequest,
  TrainingPlanResponse,
  PlanAdjustmentRequest,
  MealEditRequest,
  MealEditResponse,
} from '../../../types/ai.types';
import { generateMealPlanPrompt, generateTrainingPlanPrompt, generateMealEditPrompt } from '../prompts';
import { parseMealPlanResponse, parseTrainingPlanResponse, parseMealEditResponse } from '../parsers/planParser';

export class OpenAIProvider extends BaseAIService {
  readonly provider: AIProvider = 'openai';
  private client: OpenAI | null = null;

  constructor(config: AIServiceConfig) {
    super(config);
    if (config.apiKey) {
      this.initializeClient();
    }
  }

  private initializeClient(): void {
    if (!this.config.apiKey) {
      throw new Error('OpenAI API key is required');
    }
    this.client = new OpenAI({
      apiKey: this.config.apiKey,
      dangerouslyAllowBrowser: true, // Note: In production, use a backend proxy
    });
  }

  configure(config: AIServiceConfig): void {
    super.configure(config);
    this.initializeClient();
  }

  async generateMealPlan(request: MealPlanRequest): Promise<MealPlanResponse> {
    if (!this.client) {
      throw new Error('OpenAI client not initialized');
    }

    try {
      const { systemPrompt, userPrompt, responseFormat } = generateMealPlanPrompt(request);

      const completion = await this.client.chat.completions.create({
        model: this.config.model || 'gpt-4-turbo-preview',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt },
        ],
        response_format: responseFormat as { type: 'json_object' },
      });

      const responseContent = completion.choices[0]?.message?.content;
      if (!responseContent) {
        throw new Error('Empty response from OpenAI');
      }

      const plan = parseMealPlanResponse(responseContent);

      return {
        plan,
        generationNotes: 'Generated by OpenAI GPT-4',
      };
    } catch (error) {
      this.handleError(error, 'generateMealPlan');
    }
  }

  async generateTrainingPlan(
    request: TrainingPlanRequest
  ): Promise<TrainingPlanResponse> {
    if (!this.client) {
      throw new Error('OpenAI client not initialized');
    }

    try {
      const { systemPrompt, userPrompt, responseFormat } =
        generateTrainingPlanPrompt(request);

      const completion = await this.client.chat.completions.create({
        model: this.config.model || 'gpt-4-turbo-preview',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt },
        ],
        response_format: responseFormat as { type: 'json_object' },
      });

      const responseContent = completion.choices[0]?.message?.content;
      if (!responseContent) {
        throw new Error('Empty response from OpenAI');
      }

      const plan = parseTrainingPlanResponse(responseContent);

      return {
        plan,
        generationNotes: 'Generated by OpenAI GPT-4',
      };
    } catch (error) {
      this.handleError(error, 'generateTrainingPlan');
    }
  }

  async adjustPlan(
    request: PlanAdjustmentRequest
  ): Promise<MealPlanResponse | TrainingPlanResponse> {
    // For plan adjustment, we generate a new plan with adjustment context
    if (request.planType === 'meal') {
      const mealRequest: MealPlanRequest = {
        userProfile: request.userProfile,
        startDate: new Date(),
        durationDays: 7, // Default to 1 week
        adjustmentContext: {
          adherenceAnalysis: request.adherenceAnalysis,
          specificRequests: request.specificRequests,
        },
      };
      return await this.generateMealPlan(mealRequest);
    } else {
      const trainingRequest: TrainingPlanRequest = {
        userProfile: request.userProfile,
        startDate: new Date(),
        durationWeeks: 4, // Default to 4 weeks
        adjustmentContext: {
          adherenceAnalysis: request.adherenceAnalysis,
          specificRequests: request.specificRequests,
        },
      };
      return await this.generateTrainingPlan(trainingRequest);
    }
  }

  async editMeal(request: MealEditRequest): Promise<MealEditResponse> {
    if (!this.client) {
      throw new Error('OpenAI client not initialized');
    }

    try {
      const { systemPrompt, userPrompt, responseFormat } = generateMealEditPrompt(request);

      const completion = await this.client.chat.completions.create({
        model: this.config.model || 'gpt-4-turbo-preview',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt },
        ],
        response_format: responseFormat as { type: 'json_object' },
      });

      const responseContent = completion.choices[0]?.message?.content;
      if (!responseContent) {
        throw new Error('Empty response from OpenAI');
      }

      const meal = parseMealEditResponse(responseContent, request.meal.id);

      return {
        meal,
        editNotes: 'Edited by OpenAI GPT-4',
      };
    } catch (error) {
      this.handleError(error, 'editMeal');
    }
  }

  async healthCheck(): Promise<boolean> {
    if (!this.client) {
      return false;
    }

    try {
      const completion = await this.client.chat.completions.create({
        model: this.config.model || 'gpt-4-turbo-preview',
        messages: [{ role: 'user', content: 'Hello' }],
        max_tokens: 5,
      });

      return !!completion.choices[0]?.message;
    } catch (error) {
      console.error('OpenAI health check failed:', error);
      return false;
    }
  }
}
